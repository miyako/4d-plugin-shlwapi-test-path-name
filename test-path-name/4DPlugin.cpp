/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : test-path-name
 #	author : miyako
 #	2018/07/09
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- shlwapi

		case 1 :
			shlwapi_Test_path_name(pResult, pParams);
			break;

	}
}

#pragma mark shlwapi

#if VERSIONWIN
HANDLE createFmOut(test_path_name_result_t *result)
{
	DWORD data_len = sizeof(test_path_name_result_t);
	DWORD len = sizeof(data_len) + data_len;
	
	/*
	 structure of fmOut
	 DWORD:len
	 test_path_name_result_t
	 */
	
	HANDLE fmOut = CreateFileMapping(
																	 INVALID_HANDLE_VALUE,
																	 NULL,
																	 PAGE_READWRITE,
																	 0,
																	 len,
																	 PARAM_NAME_OUT);
	if (fmOut)
	{
		LPVOID bufOut = MapViewOfFile(fmOut,
																	FILE_MAP_WRITE,
																	0,
																	0,
																	len);
		if (bufOut)
		{
			unsigned char *p = (unsigned char *)bufOut;
			try
			{
				/* write length */
				CopyMemory(p, &data_len, sizeof(data_len));
				p += sizeof(data_len);
				if (data_len)
				{
					/* write value */
					CopyMemory(p, (void *)result, data_len);
				}
			}
			catch (...)
			{
				/* CopyMemory failed */
			}
			UnmapViewOfFile(bufOut);
		}//bufOut
	}
	
	return fmOut;
}
#endif

#if VERSIONWIN
void getFmOut(test_path_name_result_t *result)
{
#if VERSIONWIN
	DWORD data_len = 0;
	DWORD len = sizeof(data_len);
	
	BOOL success = FALSE;
	
	HANDLE fmOut = CreateFileMapping(
																	 INVALID_HANDLE_VALUE,
																	 NULL,
																	 PAGE_READWRITE,
																	 0,
																	 len,
																	 PARAM_NAME_OUT);
	/* step 1: get length */
	if (fmOut)
	{
		LPVOID bufOut = MapViewOfFile(fmOut,
																	FILE_MAP_READ,
																	0,
																	0,
																	len);
		if (bufOut)
		{
			unsigned char *p = (unsigned char *)bufOut;
			try
			{
				CopyMemory(&data_len, p, sizeof(data_len));
				success = TRUE;
			}
			catch (...)
			{
				
			}
			UnmapViewOfFile(bufOut);
		}
		CloseHandle(fmOut);
	}
	
	/* step 2: get value */
	if ((success) && (data_len))
	{
		len = len + data_len;
		
		fmOut = CreateFileMapping(
															INVALID_HANDLE_VALUE,
															NULL,
															PAGE_READWRITE,
															0,
															len,
															PARAM_NAME_OUT);
		if (fmOut)
		{
			LPVOID bufOut = MapViewOfFile(fmOut,
																		FILE_MAP_READ,
																		0,
																		0,
																		len);
			if (bufOut)
			{
				unsigned char *p = (unsigned char *)bufOut;
				p = p + sizeof(data_len);
				try
				{
					if(data_len == sizeof(test_path_name_result_t))
					{
						CopyMemory(result, p, data_len);
					}
				}
				catch (...)
				{
					
				}
				UnmapViewOfFile(bufOut);
			}
			CloseHandle(fmOut);
		}
		
	}
#endif
}
#endif

#if VERSIONWIN
HANDLE createFmIn(test_path_name_param_t *params, DWORD a_len, DWORD b_len, DWORD path_len)
{
	BOOL success = FALSE;
	
	/*
	 structure of fmIn
	 DWORD:a_len
	 DWORD:b_len
	 DWORD:path_len
	 a
	 b
	 path
	 */
	
	DWORD len
	= sizeof(a_len)
	+ sizeof(b_len)
	+ sizeof(path_len)
	+ a_len;
	+ b_len
	+ path_len;
	
	HANDLE fmIn = CreateFileMapping(
																	INVALID_HANDLE_VALUE,
																	NULL,
																	PAGE_READWRITE,
																	0, len,
																	PARAM_NAME_IN);
	if(fmIn)
	{
		LPVOID bufIn = MapViewOfFile(fmIn,
																 FILE_MAP_WRITE,
																 0,
																 0, len);
		if(bufIn)
		{
			try
			{
				unsigned char *p = (unsigned char *)bufIn;
				
				/* step 1: set length */
				CopyMemory(p, &a_len, sizeof(a_len));
				p += sizeof(a_len);
				CopyMemory(p, &b_len, sizeof(b_len));
				p += sizeof(b_len);
				CopyMemory(p, &path_len, sizeof(path_len));
				p += sizeof(path_len);
				
				/* step 2: set value */
				CopyMemory(p, params->a, a_len);
				p += a_len;
				CopyMemory(p, params->b, b_len);
				p += b_len;
				CopyMemory(p, params->path, path_len);
				
				success = TRUE;
			}
			catch(...)
			{
				/* CopyMemory() failed */
			}
			UnmapViewOfFile(bufIn);
		}//bufIn
		if(!success)
		{
			CloseHandle(fmIn);
			return 0;
		}
		
	}
	
	return fmIn;
}
#endif

#if VERSIONWIN
void getFmIn(test_path_name_param_t *params)
{
#if VERSIONWIN
	DWORD a_len = 0;
	DWORD b_len = 0;
	DWORD path_len = 0;
	
	DWORD len = sizeof(a_len) + sizeof(b_len) + sizeof(path_len);
	
	BOOL success = FALSE;
	
	HANDLE fmIn = CreateFileMapping(
																	INVALID_HANDLE_VALUE,
																	NULL,
																	PAGE_READWRITE,
																	0,
																	len,
																	PARAM_NAME_IN);
	/* step 1: get length */
	if (fmIn)
	{
		LPVOID bufIn = MapViewOfFile(fmIn,
																	FILE_MAP_READ,
																	0,
																	0,
																	len);
		if (bufIn)
		{
			unsigned char *p = (unsigned char *)bufIn;
			try
			{
				CopyMemory(&a_len, p, sizeof(a_len));
				p += sizeof(a_len);
				CopyMemory(&b_len, p, sizeof(b_len));
				p += sizeof(b_len);
				CopyMemory(&path_len, p, sizeof(path_len));
				
				success = TRUE;
			}
			catch (...)
			{
				
			}
			UnmapViewOfFile(bufIn);
		}
		CloseHandle(fmIn);
	}
	
	/* step 2: get value */
	if ((success) && (a_len) && (b_len) && (path_len))
	{
		len = len + a_len + b_len + path_len;
		
		fmIn = CreateFileMapping(
															INVALID_HANDLE_VALUE,
															NULL,
															PAGE_READWRITE,
															0,
															len,
															PARAM_NAME_IN);
		if (fmIn)
		{
			LPVOID bufIn = MapViewOfFile(fmIn,
																		FILE_MAP_READ,
																		0,
																		0,
																		len);
			if (bufIn)
			{
				unsigned char *p = (unsigned char *)bufIn;
				p = p + sizeof(a_len) + sizeof(b_len) + sizeof(path_len);
				try
				{
					CopyMemory(params->a, p, a_len);
					p += a_len;
					CopyMemory(params->b, p, b_len);
					p += b_len;
					CopyMemory(params->path, p, path_len);
					
				}
				catch (...)
				{
					
				}
				UnmapViewOfFile(bufIn);
			}
			CloseHandle(fmIn);
		}
		
	}
#endif
}
#endif

#if VERSIONWIN
unsigned __stdcall test_path_name(void *_param)
{
#if VERSIONWIN

	test_path_name_param_t param;
	memset(&param, 0x0, sizeof(test_path_name_param_t));

	getFmIn(&param);
	
	LPCTSTR path = param.path;
	
	test_path_name_result_t result;
	result.value = does_not_exist;
	
	HANDLE b = CreateEvent(NULL,
												 TRUE,
												 FALSE,
												 (const wchar_t *)param.b);
	if(b)
	{
		/* main */
		if (PathIsDirectory(path))
		{
			result.value = is_a_folder;
		}
		else
		{
			if (PathFileExists(path))
			{   /* because this fn returns false for shared folder, test folder first */
				result.value = is_a_document;
			}
		}
	
		/* end of main */

		HANDLE fmOut = createFmOut(&result);
		
		if (fmOut)
		{
			HANDLE a = OpenEvent(EVENT_ALL_ACCESS,
													 FALSE,
													 (const wchar_t *)param.a);
			
			if (a)
			{
				SetEvent(a);
				CloseHandle(a);
			}
			
			WaitForSingleObject(b, INFINITE);
			ResetEvent(b);
			
			CloseHandle(fmOut);
		}
	
		CloseHandle(b);
	}

	_endthreadex(0);
#endif
	return 0;
}
#endif

// ------------------------------------ shlwapi -----------------------------------

void generateUuid(std::wstring &uid)
{
#if VERSIONWIN
	RPC_WSTR str;
	UUID uuid;

	UuidCreateSequential(&uuid);
	/* the uuid only needs to be unique locally */
	/* https://docs.microsoft.com/ja-jp/windows/desktop/api/rpcdce/nf-rpcdce-uuidcreatesequential */
	if (UuidToString(&uuid, &str) == RPC_S_OK)
	{
		uid = (const wchar_t *)str;
		RpcStringFree(&str);
	}/* UuidToString */
#endif
}

void PA_YieldAbsolute2()
{
	PA_Variable	params;
	PA_ExecuteCommandByID(CMD_IDLE, &params, 0);/* PA_YieldAbsolute is not thread-safe */
}

#if VERSIONWIN
void waitForEvent(HANDLE h,
									HANDLE a,
									test_path_name_param_t *param,
									test_path_name_result_t *result)
{
	BOOL exit = FALSE;
	
	do {
		switch (WaitForSingleObject(a, WAIT_TIMEOUT_MS))
		{
			case WAIT_ABANDONED:
			case WAIT_FAILED:
				exit = TRUE;
				break;
			case WAIT_TIMEOUT:
				PA_YieldAbsolute2();
				break;
			case WAIT_OBJECT_0:
				ResetEvent(a);
				BOOL success = FALSE;
				
				getFmOut(result);
				
				HANDLE b = OpenEvent(EVENT_ALL_ACCESS, FALSE, param->b);
				
				if(b)
				{
					/* tell c to die */
					SetEvent(b);
					CloseHandle(b);
				}
				
				do {
					switch (WaitForSingleObject(h, WAIT_TIMEOUT_MS))
					{
						case WAIT_TIMEOUT:
							PA_YieldAbsolute2();
							break;
						case WAIT_ABANDONED:
						case WAIT_FAILED:
						case WAIT_OBJECT_0:
							exit = TRUE;
							break;
					}
				} while (!exit);
				
				exit = TRUE;
				break;
		}
		
	} while (!exit);
}
#endif

void generate_uuid_pair(std::wstring &a, std::wstring &b)
{
	generateUuid(a);
	generateUuid(b);
}

void shlwapi_Test_path_name(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT returnValue;

	Param1.fromParamAtIndex(pParams, 1);
	returnValue.setIntValue(does_not_exist);
	
#if VERSIONWIN
	
	using namespace std;
	
	wstring uuid_in, uuid_out;
	generate_uuid_pair(uuid_in, uuid_out);
	
	HANDLE a = CreateEvent(NULL, /* the handle cannot be inherited by child processes */
												 TRUE, /* creates a manual-reset event object */
												 FALSE, /* initial state of the event object */
												 uuid_in.c_str());
	if(a)
	{
		test_path_name_param_t param;
		memset(&param, 0x0, sizeof(test_path_name_param_t));

		DWORD a_len = uuid_in.length() * sizeof(wchar_t);
		CopyMemory(param.a, uuid_in.c_str(), a_len);

		DWORD b_len = uuid_out.length() * sizeof(wchar_t);
		CopyMemory(param.b, uuid_out.c_str(), b_len);

		DWORD path_len = Param1.getUTF16Length() * sizeof(PA_Unichar);
		CopyMemory(param.path, Param1.getUTF16StringPtr(), path_len);
		
		HANDLE fmIn = createFmIn(&param, a_len, b_len, path_len);
		
		if(fmIn)
		{
			HANDLE h = (HANDLE)_beginthreadex(NULL /* security: handle not inherited */,
																				0 /* stack size:default */,
																				test_path_name,
																				&param /* arguments */,
																				0 /* init flags:execute immediately */,
																				NULL /* thread id */);
			if(h)
			{
				test_path_name_result_t result;
				
				waitForEvent(h,
										 a,
										 &param,
										 &result);
				
				returnValue.setIntValue(result.value);
				
				CloseHandle(h);
			}
			
			CloseHandle(fmIn);
		}

		CloseHandle(a);
	}
#endif
	
	returnValue.setReturn(pResult);
}

